<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AI - éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
    // 1. å³ã‚¯ãƒªãƒƒã‚¯ï¼ˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼ï¼‰ã‚’ç¦æ­¢ã™ã‚‹
    document.addEventListener('contextmenu', function(e) {
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼è¡¨ç¤ºã‚’é˜»æ­¢ã™ã‚‹
        e.preventDefault();
        console.log("å³ã‚¯ãƒªãƒƒã‚¯ã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚");
        // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã™ã‚‹
        // alert("ãƒšãƒ¼ã‚¸ã®ã‚½ãƒ¼ã‚¹é–²è¦§ã‚„ã‚³ãƒ”ãƒ¼ã¯è¨±å¯ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
    });

    // 2. F12ã‚­ãƒ¼ã‚„Ctrl/Cmd+Uã‚’ç„¡åŠ¹ã«ã™ã‚‹
    document.onkeydown = function(e) {
        // ã‚­ãƒ¼ã‚³ãƒ¼ãƒ‰ã®å–å¾— (e.keyã¯ãƒ¢ãƒ€ãƒ³ãªãƒ–ãƒ©ã‚¦ã‚¶ã§æ¨å¥¨)
        const key = e.key;
        
        // F12ã‚­ãƒ¼ (é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«)
        if (key === 'F12') {
            e.preventDefault();
            console.log("F12ã‚­ãƒ¼æ“ä½œã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚");
            return false;
        }

        // Ctrl+Shift+I, Cmd+Option+I (é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ)
        if (e.ctrlKey && e.shiftKey && key === 'I') {
            e.preventDefault();
            console.log("é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚");
            return false;
        }

        // Ctrl+U, Cmd+U (ãƒšãƒ¼ã‚¸ã®ã‚½ãƒ¼ã‚¹è¡¨ç¤ºã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ)
        if (e.ctrlKey && key === 'u' || e.ctrlKey && key === 'U') {
            e.preventDefault();
            console.log("ã‚½ãƒ¼ã‚¹è¡¨ç¤ºã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã¯ç¦æ­¢ã•ã‚Œã¦ã„ã¾ã™ã€‚");
            return false;
        }
    };
</script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #ffffff;
            overflow: hidden; /* CanvasãŒå…¨ç”»é¢ã‚’å ã‚ã‚‹ãŸã‚ */
        }
        #waveCanvas {
            position: fixed;
            top: 0;
            left: 15;
            z-index: 0;
        }
        #tapArea {
            position: fixed;
            top: 0;
            left: 15;
            width: 100%;
            height: 100%;
            z-index: 20; /* Canvasã®ä¸Šã«é…ç½® */
        }
        #ui {
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
            z-index: 30; /* æœ€å‰é¢ã«é…ç½® */
        }
        #status-area {
            font-size: 1.25rem;
            line-height: 1.5;
            white-space: pre-wrap;
            min-height: 100px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: color 0.3s, box-shadow 0.3s;
            border-radius: 0.45rem;
            padding: 1rem;
        }
    </style>
</head>
<body>
    <!-- 1. Waveform Canvas (Full Screen) -->
    <canvas id="waveCanvas"></canvas>

    <!-- 2. UI Tap Area (for showing/hiding UI) -->
    <div id="tapArea"></div>

    <!-- 3. Main UI Overlay -->
    <div id="ui" class="fixed inset-0 flex flex-col justify-between items-center p-6 sm:p-10 pointer-events-none">
        
        <!-- Status Display Area (Top) -->
        <div id="status-area" class="text-center font-mono font-bold mt-10 w-full max-w-lg pointer-events-auto bg-gray-900/70 backdrop-blur-sm shadow-2xl border border-cyan-500/30">
            AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆèµ·å‹•ä¸­...
        </div>

        <!-- Input Controls (Bottom) -->
        <div id="input-controls" class="w-full max-w-xl flex flex-col items-center space-y-4 mb-4 sm:mb-8 pointer-events-auto">
            
            <!-- Transcript/Input Box -->
            <textarea id="messageInput" class="w-full p-3 text-lg rounded-xl shadow-lg bg-gray-800/90 text-white placeholder-gray-400 border border-purple-500/50 focus:outline-none focus:ring-2 focus:ring-cyan-400 resize-none transition duration-300" 
                      placeholder="ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã™ã‚‹ã‹ã€è©±ã—ã‹ã‘ã¦ãã ã•ã„..." rows="2"></textarea>
            
            <!-- Send/Reset Button -->
            <button id="sendBtn" class="w-16 h-16 rounded-full bg-indigo-600 hover:bg-indigo-500 transition duration-300 transform hover:scale-105 shadow-xl text-white text-3xl flex items-center justify-center font-bold border-4 border-white/50 focus:outline-none focus:ring-4 focus:ring-pink-400/50">
                <span role="img" aria-label="Reset/Send">âœˆï¸</span>
            </button>
            <div class="text-xs text-gray-400 mt-2">ï¼ˆâœˆï¸ãƒœã‚¿ãƒ³ã§ãƒªã‚»ãƒƒãƒˆ/ãƒã‚¤ã‚¯å†èµ·å‹•ã€ã¾ãŸã¯ç”»é¢ã‚¿ãƒƒãƒ—ã§UIè¡¨ç¤ºåˆ‡æ›¿ï¼‰</div>
        </div>
    </div>
    
    <!-- JavaScript Logic -->
    <script>
        /* ----------- ã‚¹ãƒãƒ›å›è»¢æ™‚ã«ã‚‚Canvasã‚’ãƒ•ã‚£ãƒƒãƒˆã•ã›ã‚‹ ----------- */
        function resizeCanvas() {
            const canvas = document.getElementById("waveCanvas");
            // ç”»é¢ã®ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦Canvasã®ã‚µã‚¤ã‚ºã‚’èª¿æ•´
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // ãƒãƒ¼ã®ä½ç½®ã‚’å†è¨ˆç®—
            if (typeof createBars === 'function') {
                createBars();
            }
        }

        window.addEventListener("load", resizeCanvas);
        window.addEventListener("resize", resizeCanvas);
        window.addEventListener("orientationchange", () => {
            // å›è»¢å¾Œã®å€¤ãŒå®‰å®šã—ã¦ã‹ã‚‰å†è¨ˆç®—
            setTimeout(resizeCanvas, 300); 
        });

        /* ---------- Canvasã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–¢é€£ ---------- */
        const canvas = document.getElementById("waveCanvas");
        const ctx = canvas.getContext("2d");
        
        // åˆæœŸã®Canvasã‚µã‚¤ã‚ºè¨­å®šï¼ˆresizeCanvasã§ä¸Šæ›¸ãã•ã‚Œã‚‹ï¼‰
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let bars = [];
        const barCount = 40;
        const barWidth = 8;
        let waveY = canvas.height / 2; // ä¸­å¤®Yåº§æ¨™
        let dataArray; 
        
        let animationFrameId;
        let isSpeaking = false; 
        let isRecording = false; 

        function createBars() {
            // Canvasã‚µã‚¤ã‚ºå¤‰æ›´ã«ä¼´ã„ã€ä¸­å¤®Yåº§æ¨™ã¨ãƒãƒ¼ã‚’å†åˆæœŸåŒ–
            waveY = canvas.height / 2;
            bars = [];
            // ãƒãƒ¼ã‚’ä¸­å¤®ã«é…ç½®ã™ã‚‹ãŸã‚ã®é–‹å§‹Xåº§æ¨™ã‚’è¨ˆç®—
            const startX = canvas.width / 2 - (barCount * barWidth) / 2;
            for (let i = 0; i < barCount; i++) {
                bars.push({
                    x: startX + i * barWidth * 2.5, // é–“éš”ã‚’åºƒã’ã‚‹ãŸã‚ * 2.5
                    height: 10,
                    // å¾…æ©Ÿæ™‚ã®è‰²
                    color: "#00ffff"
                });
            }
        }

        function drawBars() {
            bars.forEach(bar => {
                ctx.fillStyle = bar.color;
                // ãƒãƒ¼ã‚’ä¸­å¿ƒã«æç”»
                ctx.fillRect(bar.x, waveY - bar.height / 2, barWidth * 2, bar.height); 
            });
        }

        function animateBars() {
            // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢ï¼ˆTailwindã®èƒŒæ™¯è‰²ã‚’æ´»ã‹ã™ï¼‰
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (isRecording && analyser && audioContext.state === 'running' && dataArray) {
                // ãƒã‚¤ã‚¯å…¥åŠ›ä¸­ã®å‹•çš„æ³¢å½¢
                analyser.getByteFrequencyData(dataArray);

                const step = Math.floor(dataArray.length / barCount); 
                
                bars.forEach((bar, i) => {
                    // å‘¨æ³¢æ•°ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰éŸ³é‡ã‚’è¨ˆç®—
                    const volume = dataArray[i * step] / 255; 
                    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®é«˜ã•ã‚’è¨­å®š (æœ€å°20ã€æœ€å¤§200)
                    let targetHeight = volume * 180 + 20; 

                    // ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆæ…£æ€§ï¼‰
                    bar.height += (targetHeight - bar.height) * 0.15;
                    // è‰²ã‚’é»„è‰²ã«è¨­å®š
                    bar.color = '#ffff00';
                });

            } else if (isSpeaking) {
                // AIå¿œç­”ä¸­ã®æ“¬ä¼¼çš„ãªå‹•çš„æ³¢å½¢ (TTS)
                bars.forEach(bar => {
                    // æœ€å°20ã‹ã‚‰æœ€å¤§100ã®ç¯„å›²ã§å‹•ãã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
                    let targetHeight = Math.random() * 80 + 20;
                    bar.height += (targetHeight - bar.height) * 0.15;
                    // è‰²ã‚’ç·‘è‰²ã«è¨­å®š
                    bar.color = '#00ffaa';
                });
            } else {
                // å¾…æ©Ÿä¸­ã®æ§ãˆã‚ãªå‹•ã
                bars.forEach(bar => {
                    // æœ€å°10ã‹ã‚‰æœ€å¤§20ã®ç¯„å›²ã§ã‚ãšã‹ã«å‹•ã
                    let targetHeight = 10 + Math.random() * 10;
                    bar.height += (targetHeight - bar.height) * 0.15;
                    // è‰²ã‚’ã‚·ã‚¢ãƒ³ã«è¨­å®š
                    bar.color = "#00ffff";
                });
            }

            drawBars();
            animationFrameId = requestAnimationFrame(animateBars);
        }

        
        /* --- 2. éŸ³å£°èª­ã¿ä¸Šã’/èªè­˜/APIé€£æºé–¢é€£ --- */
        
        // DOMè¦ç´ ã®å–å¾—
        const statusArea = document.getElementById("status-area");
        const sendBtn = document.getElementById("sendBtn"); 
        const input = document.getElementById("messageInput"); 
        // const transcriptBox = document.getElementById('transcript'); // æœªä½¿ç”¨
        const ui = document.getElementById('ui'); 
        const tapArea = document.getElementById('tapArea'); 
        
        // APIè¨­å®š (ã”è‡ªèº«ã®ç’°å¢ƒã«åˆã‚ã›ã¦å¤‰æ›´ã—ã¦ãã ã•ã„)
        const API_KEY = ""; 
        // ãƒ­ãƒ¼ã‚«ãƒ«FastAPIãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®URL
        // const LLM_API_URL = "http://127.0.0.1:8001/generate";
        // const MQTT_API_URL = "http://127.0.0.1:8000/control"; 
        const LLM_API_URL = "https://atjmuwnwmtjw-nose.hf.space/llm/generate";
        const MQTT_API_URL = "https://atjmuwnwmtjw-nose.hf.space/iot/control"; 

        // çŠ¶æ…‹ç®¡ç†å¤‰æ•°
        const synth = window.speechSynthesis;
        let audioContext, analyser, mediaStream;
        let recognition = null; 
        let currentTextToSpeak = ''; 
        
        // --- ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° (è‰²ã®è£œé–“) ---
        // ã“ã®ã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ã¯ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒæä¾›ã—ãŸJSã‚’ãã®ã¾ã¾ä½¿ç”¨ã—ã¦ã„ã¾ã™ã€‚
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return [r, g, b];
        }

        function rgbToHex(r, g, b) {
            const toHex = (c) => ('0' + Math.max(0, Math.min(255, c)).toString(16)).slice(-2);
            return '#' + toHex(Math.round(r)) + toHex(Math.round(g)) + toHex(Math.round(b));
        }
        
        function startColorTransition(startColor, endColor, duration = 2000) {
            const startTime = performance.now();
            const startRgb = hexToRgb(startColor);
            const endRgb = hexToRgb(endColor);

            function interpolate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(1, elapsed / duration);
                
                const r = startRgb[0] + (endRgb[0] - startRgb[0]) * progress;
                const g = startRgb[1] + (endRgb[1] - startRgb[1]) * progress;
                const b = startRgb[2] + (endRgb[2] - startRgb[2]) * progress; 
                
                const currentColor = rgbToHex(r, g, b);
                
                statusArea.style.color = currentColor;
                statusArea.style.boxShadow = `0 0 20px ${currentColor}80`;

                if (progress < 1) {
                    requestAnimationFrame(interpolate);
                }
            }
            
            requestAnimationFrame(interpolate);
        }
        
        /* ---------- UI helpers ---------- */

        function updateStatus(message, color = '#00ffff') {
            statusArea.innerHTML = message; 
            statusArea.style.color = color;
            statusArea.style.boxShadow = `0 0 20px ${color}80`;
        }
        Â  function setStandbyStatus() {
Â  Â  Â  Â  Â  Â  const standbyMsg = `
Â  Â  Â  Â  Â  Â  ãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AI
Â  Â  Â  Â  Â  Â  KS-903model8906-c4-70e
Â  Â  Â  Â  Â  Â  AIã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆå¾…æ©Ÿä¸­...
Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  updateStatus(standbyMsg.trim(), '#00ffff');
Â  Â  Â  Â  }
        
        
        /* ---------- TTS (Speech Synthesis) ---------- */

        /**
         * LLMå¿œç­”ãªã©ã€AIã‹ã‚‰ã®æ­£å¼ãªå¿œç­”ã‚’èª­ã¿ä¸Šã’ã€çµ‚äº†å¾Œã«STTã‚’å†èµ·å‹•ã™ã‚‹
         */
        function speak(text){ 
            if(!text) return; 
            
            currentTextToSpeak = text; 
            
            if(synth.speaking) synth.cancel(); 
            
            isSpeaking = true; 

            const u = new SpeechSynthesisUtterance(text); 
            u.lang='ja-JP'; 
            u.rate=1.0; 
            u.onstart=()=>{ 
                const display = text.length > 20 ? text.substring(0, 20) + '...' : text;
                const formattedStatus = `
                ãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AI
Â  Â  Â  Â  Â  Â  Â  Â  KS-903model8906-c4-70eAPIã®å¿œç­”
Â  Â  Â  Â  Â  Â  Â  Â  ã€Œ${display}ã€
                `;
                updateStatus(formattedStatus.trim(), '#00ffaa');

              
            }; 
            u.onend=()=>{ 
                isSpeaking = false; 
                currentTextToSpeak = ''; 
                setStandbyStatus();
                input.value = '';

                // TTSçµ‚äº†å¾Œã€STTãŒåœæ­¢ã—ã¦ã„ã‚Œã°è‡ªå‹•ã§å†èµ·å‹•ã‚’è©¦ã¿ã‚‹
                if (recognition && !isRecording) {
                    try {
                        recognition.start();
                    } catch(e) {
                        console.warn('Recognition restart failed after TTS:', e);
                    }
                }
            }; 
            u.onerror = (e) => {
                console.error('TTS error:', e);
                isSpeaking = false;
                currentTextToSpeak = '';
                setStandbyStatus();
                input.value = '';
            };

            synth.speak(u); 
        }

        /**
         * ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›æ™‚ã®å³æ™‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨èª­ã¿ä¸Šã’é–¢æ•°ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«ç§»å‹•ï¼‰
         */
        function speakSentence(text) {
            // ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã‹ã€æ—¢ã«åŒã˜ãƒ†ã‚­ã‚¹ãƒˆã®èª­ã¿ä¸Šã’ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
            if (text.trim() === '' || text === currentTextToSpeak) {
                return;
            }

            // æ–°ã—ã„èª­ã¿ä¸Šã’ãŒé–‹å§‹ã•ã‚Œã‚‹ã®ã§ã€ç¾åœ¨ã®èª­ã¿ä¸Šã’ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
            if (synth.speaking) {
                synth.cancel();
            }
            
            currentTextToSpeak = text; // æ–°ã—ã„æ–‡ç« ã‚’è¨˜æ†¶

            const utterance = new SpeechSynthesisUtterance(text); // const/let ã‚’ä½¿ç”¨
            utterance.lang = 'ja-JP'; // æ—¥æœ¬èªã‚’è¨­å®š
            utterance.rate = 1.0; 

            utterance.onstart = () => {
                isSpeaking = true;
                // èª­ã¿ä¸Šã’ä¸­ã®æ–‡ç« ã‚’ä¸€éƒ¨è¡¨ç¤º
                const display = text.length > 20 ? text.substring(0, 20) + '...' : text;
                updateStatus(`æ–‡ç« ã‚’èª­ã¿ä¸Šã’ä¸­: ã€Œ${display}ã€`, '#00ffaa');
            };
            
            utterance.onend = () => {
                isSpeaking = false;
                // å³æ™‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒçµ‚ã‚ã£ã¦ã‚‚ã€å¾…æ©Ÿä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«æˆ»ã™ã ã‘
                setStandbyStatus(); 
            };

            utterance.onerror = (event) => {
                console.error('Speech Synthesis Error:', event);
                isSpeaking = false;
                updateStatus('èª­ã¿ä¸Šã’ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', '#ff0000');
            };

            synth.speak(utterance);
        }

        /* ---------- Speech Recognition (Browser STT) & Audio Init ---------- */

        function startBrowserRecognition() {
            if (isRecording) return;
            
            if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                updateStatus('Error: Speech Recognition not supported in this browser.', '#ff0000');
                return;
            }

            if (recognition) {
                recognition.stop();
                recognition = null;
            }

            recognition = new (window.webkitSpeechRecognition || window.SpeechRecognition)();
            recognition.continuous = false; 
            recognition.interimResults = true; 
            recognition.lang = 'ja-JP';

            recognition.onstart = () => {
                isRecording = true;
                isSpeaking = true; 
                const standbyMsg = `
                Listening...
                è©±ã—ã‹ã‘ã¦ãã ã•ã„...ï¼
                `;
                updateStatus(standbyMsg.trim(), '#ffff00');
                startColorTransition('#ffff00', '#00ffaa', 2000); 
                
                input.value = ''; 
                if (synth.speaking) synth.cancel(); 
            };

            recognition.onresult = (event) => {
                let interimTranscript = '';
                let finalTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }
                input.value = finalTranscript || interimTranscript; // å…¥åŠ›æ¬„ã«ã¯åæ˜ 
            };

            // ç™ºè©±çµ‚äº†ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼æ™‚ã®è‡ªå‹•å†ã‚¹ã‚¿ãƒ¼ãƒˆãƒ­ã‚¸ãƒƒã‚¯
            const restartRecognition = () => {
                isRecording = false;
                
                // TTSãŒå‹•ä½œä¸­ã§ãªã‘ã‚Œã°ã€å¾…æ©ŸçŠ¶æ…‹ã«æˆ»ã™
                if (!synth.speaking) {
                    isSpeaking = false; 
                    setStandbyStatus();
                }
                
                setTimeout(() => {
                    try {
                        // æ—¢ã«èªè­˜ãŒé–‹å§‹ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
                        if (!isRecording && !synth.speaking) recognition.start(); 
                    } catch (e) {
                        if (e.name !== 'InvalidStateError') {
                            console.warn('Recognition start failed:', e);
                        }
                    }
                }, 500); 
            };
            
            recognition.onend = () => {
                isRecording = false;
                
                // TTSãŒå‹•ä½œã—ã¦ã„ãªã„å ´åˆã«é™ã‚Š isSpeaking ã‚’ false ã«
                if (!synth.speaking) {
                    isSpeaking = false; 
                }
                
                const finalPrompt = input.value.trim(); // transcriptBoxã®ä»£ã‚ã‚Šã«input.valueã‚’ä½¿ã†
                
                // èªè­˜çµæœãŒç©ºã§ãªã„ã€ã¾ãŸã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ãªã„å ´åˆã®ã¿å‡¦ç†
                if (finalPrompt && finalPrompt.length > 1 && !finalPrompt.startsWith("è©±ã—ã‹ã‘ã¦ãã ã•ã„") && !finalPrompt.startsWith("ãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AI  KS-903model8906-c4-70eAPIã®å¿œç­”:")) {
                    updateStatus('Processing response...', '#00ffaa');
                    
                    // LLMå‡¦ç†ä¸­ã«STTãŒè‡ªå‹•ã§å†èµ·å‹•ã—ãªã„ã‚ˆã†ã«ã€.finallyã§restartRecognitionã‚’å‘¼ã¶
                    processRecognitionResult(finalPrompt).finally(() => {
                        // TTSãŒçµ‚äº†ã—ãŸå¾Œã«å†èµ·å‹•ã•ã›ã‚‹ (speaké–¢æ•°å†…ã®onendã§ã‚‚å®Ÿæ–½ã•ã‚Œã‚‹ãŸã‚å†—é•·ã§ã¯ã‚ã‚‹ãŒå¿µã®ãŸã‚)
                        if (!synth.speaking) {
                            restartRecognition(); 
                        }
                    });
                } else {
                    restartRecognition();
                }
            };

            recognition.onerror = (event) => {
                isRecording = false;
                isSpeaking = false;
                console.error('Speech Recognition Error:', event.error);
                
                if (event.error !== 'not-allowed' && event.error !== 'aborted') {
                    restartRecognition();
                } else if (event.error === 'aborted') {
                    // æ„å›³çš„ãªåœæ­¢ï¼ˆstop()å‘¼ã³å‡ºã—ï¼‰ã®å ´åˆã‚‚ã‚ã‚‹ãŸã‚ã€å†èµ·å‹•
                    restartRecognition(); 
                } else {
                    updateStatus('Error: Microphone permission denied or failed.', '#ff0000');
                }
            };

            try {
                recognition.start();
            } catch (e) {
                console.warn('Initial recognition start failed:', e);
            }
        }

        async function initAudioAndSTT(){
            // AudioContextãŒæ—¢ã«åˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚Œã°STTã®ã¿å†é–‹
            if(analyser) {
                startBrowserRecognition();
                return;
            }
            updateStatus('Requesting microphone access...');

            try {
                // AudioContextã®åˆæœŸåŒ–
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // AudioContextãŒsuspendedã®å ´åˆã€å†é–‹ã‚’è©¦ã¿ã‚‹ï¼ˆiOSãªã©ã§å¿…è¦ï¼‰
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                // ãƒã‚¤ã‚¯ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®å–å¾—
                mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const sourceNode = audioContext.createMediaStreamSource(mediaStream);
                
                // ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ã«æ¥ç¶šï¼ˆæ³¢å½¢æç”»ç”¨ï¼‰
                sourceNode.connect(analyser);

                // STTã‚’é–‹å§‹
                startBrowserRecognition();

                updateStatus('Listening...', '#ffff00');
            } catch (e) {
                console.error('Audio initialization failed:', e);
                updateStatus('Error: Microphone access denied or failed to initialize.', '#ff0000');
            }
        }

        /**
         * FastAPI/MQTTãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡ã™ã‚‹é–¢æ•°
         */
        async function sendIoTCommand(command) {
            updateStatus(`Executing IoT command: ${command}...`, '#00ffaa');
            
            try {
                const response = await fetch(MQTT_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: command })
                });

                const data = await response.json();

                if (response.ok) {
                    const successMsg = `æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚${command === 'ON' ? 'é›»æ°—ã‚’ã¤ã‘ã¾ã—ãŸ' : 'é›»æ°—ã‚’æ¶ˆã—ã¾ã—ãŸ'}ã€‚`;
                    speak(successMsg);
                } else {
                    const detail = data.detail || "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼";
                    const errorMsg = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚IoTã‚³ãƒãƒ³ãƒ‰ '${command}' ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°: ${detail}`;
                    speak(errorMsg);
                }
            } catch (error) {
                const networkErrorMsg = `ğŸ”´ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: IoTãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ (${error.message})ã€‚ã‚¢ãƒ‰ãƒ¬ã‚¹: ${MQTT_API_URL}`;
                speak(networkErrorMsg);
            }
        }


        /* ---------- çµ±åˆã•ã‚ŒãŸãƒ¡ã‚¤ãƒ³å‡¦ç†é–¢æ•° (IoT or LLM) ---------- */

        async function processRecognitionResult(finalPrompt) {
            // 1. IoTã‚³ãƒãƒ³ãƒ‰ã®åˆ¤å®šã¨æŒ¯ã‚Šåˆ†ã‘
            const lowerPrompt = finalPrompt.toLowerCase();
            let iotCommand = null;

            if ((lowerPrompt.includes('ãƒ©ã‚¤ãƒˆ') || lowerPrompt.includes('é›»æ°—')) && (lowerPrompt.includes('ã¤ã‘') || lowerPrompt.includes('ã‚ªãƒ³') || lowerPrompt.includes('ç‚¹ã‘'))) {
                iotCommand = 'ON';
            } else if ((lowerPrompt.includes('ãƒ©ã‚¤ãƒˆ') || lowerPrompt.includes('é›»æ°—')) && (lowerPrompt.includes('ã‘ã—') || lowerPrompt.includes('ã‚ªãƒ•') || lowerPrompt.includes('æ¶ˆã—'))) {
                iotCommand = 'OFF';
            }

            if (iotCommand) {
                await sendIoTCommand(iotCommand);
                return; 
            }
            
            // 2. LLMå¿œç­”ç”Ÿæˆï¼ˆIoTã‚³ãƒãƒ³ãƒ‰ã§ãªã‹ã£ãŸå ´åˆï¼‰
            await generateAndSpeakResponse(finalPrompt);
        }


        /* ---------- LLM (Gemini) API & TTS é€£æº ---------- */
        async function generateAndSpeakResponse(prompt) {
            updateStatus('Generating response (via FastAPI)...', '#00ffaa');
            
            const cleanedPrompt = prompt.replace(/^ãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AI  KS-903model8906-c4-70eAPIã®å¿œç­”:\s*/, '').trim();
            if (!cleanedPrompt) {
                return; 
            }

            
          ã€€const systemInstruction = "ã‚ãªãŸã¯ã€Œãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AIã€ã¨ã„ã†åç§°ã®KS-903model8906-c4-70eã¨ã„ã†éŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã«æ—¥æœ¬èªã§ã€ç°¡æ½”ã‹ã¤ä¸å¯§ã«ç­”ãˆã¦ãã ã•ã„ã€‚";


            // Gemini APIã®ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰
            const payload = {
                prompt: cleanedPrompt,
                contents: [{ parts: [{ text: cleanedPrompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
                tools: [{ "google_search": {} }], 
                // æ³¨æ„: APIã‚­ãƒ¼ã¯ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å´ã§å‡¦ç†ã•ã‚Œã‚‹ã“ã¨ã‚’æƒ³å®šã—ã¦ã„ã¾ã™
            };
            
           

          Â  const MAX_RETRIES = 3;
Â  Â  Â  Â  Â  Â  let responseText = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AIã®KS-903model8906-c4-70eã®å¿œç­”ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚Generaltebãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ (ãƒãƒ¼ãƒˆ8004) ã®å®Ÿè¡ŒçŠ¶æ…‹ã¨APIã‚­ãƒ¼ã‚’å†ç¢ºèªã—ã¦ãã ã•ã„ã€‚";

            for (let i = 0; i < MAX_RETRIES; i++) {
                try {
                    const response = await fetch(LLM_API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ detail: `HTTP ${response.status} Error.` }));
                        throw new Error(`FastAPI Error! Status: ${response.status}. Detail: ${errorData.detail}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result && result.text) {
                        responseText = result.text;
                        break; 
                    } else {
                        throw new Error("Empty response or invalid JSON structure from FastAPI.");
                    }

               } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error(`FastAPI call error on attempt ${i + 1}:`, e);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (i === MAX_RETRIES - 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  responseText = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ¦ãƒ¼ã‚¹ã‚¯ã‚¨ã‚¢AIã®KS-903model8906-c4-70eã®å¿œç­”ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚Generaltebãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ (ãƒãƒ¼ãƒˆ8004) ã®å®Ÿè¡ŒçŠ¶æ…‹ã¨APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // æŒ‡æ•°é–¢æ•°çš„ãƒãƒƒã‚¯ã‚ªãƒ•
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const delay = 2 ** i * 1000 + Math.random() * 500;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  await new Promise(resolve => setTimeout(resolve, delay));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
                }
            }
          

            updateStatus('Speaking response...', '#00ffaa');
            speak(responseText); 
            
            return Promise.resolve();
        }

        /* ---------- ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©ã®çµ±åˆã¨å®šç¾© ---------- */

        // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›æ¬„ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ  (Enterã‚­ãƒ¼ã§å‡¦ç†)
        input.addEventListener('keydown', (e) => {
            // Enterã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸå ´åˆï¼ˆæ”¹è¡Œã‚’é˜²ãã€å‡¦ç†ã‚’é–‹å§‹ï¼‰
            if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey) {
                e.preventDefault(); 
                
                const textPrompt = input.value.trim();
                
                if (textPrompt) {
                    // éŸ³å£°èªè­˜ãŒå®Ÿè¡Œä¸­ã®å ´åˆã¯å¼·åˆ¶åœæ­¢
                    if (recognition && isRecording) {
                        recognition.stop(); 
                    }
                    // TTSã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼ˆå³æ™‚èª­ã¿ä¸Šã’ã‚’åœæ­¢ï¼‰
                    if(synth.speaking) synth.cancel(); 
                    
                    // å‡¦ç†ã‚’å„ªå…ˆ
                    updateStatus('Processing text input...', '#ffff00');
                    
                    // LLMå‡¦ç†ã‚’å®Ÿè¡Œ
                    processRecognitionResult(textPrompt).catch(error => {
                        console.error("Text input processing failed:", error);
                    }).finally(() => {
                        // input.valueã¯speakã®onendã§ã‚¯ãƒªã‚¢ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„
                    });
                }
            }
        });

        // ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã®ãŸã³ã«ç¾åœ¨ã®å†…å®¹ã‚’èª­ã¿ä¸Šã’ã‚‹æ©Ÿèƒ½ã®è¿½åŠ  (TTSå³æ™‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼)
        input.addEventListener('input', (event) => {
            const currentText = input.value.trim();
            
            // éŸ³å£°èªè­˜ãŒå®Ÿè¡Œä¸­ã§ãªã„ã€ã‹ã¤ã€AIãŒå¿œç­”ä¸­ã§ãªã„å ´åˆã«ã®ã¿å®Ÿè¡Œ
            // ã‹ã¤ã€ç¾åœ¨ã®ãƒ†ã‚­ã‚¹ãƒˆãŒèª­ã¿ä¸Šã’ä¸­ã®ãƒ†ã‚­ã‚¹ãƒˆã¨ç•°ãªã‚‹å ´åˆ
            if (!isRecording && !isSpeaking && currentText.length > 0 && currentText !== currentTextToSpeak) {
                speakSentence(currentText); 
            } else if (currentText.length === 0 && synth.speaking) {
                // ãƒ†ã‚­ã‚¹ãƒˆãŒå…¨ã¦å‰Šé™¤ã•ã‚Œã€ã‹ã¤èª­ã¿ä¸Šã’ä¸­ã®å ´åˆã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¦å¾…æ©ŸçŠ¶æ…‹ã«æˆ»ã™
                synth.cancel();
                isSpeaking = false;
                setStandbyStatus();
            }
        });

        // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®æ©Ÿèƒ½ (STTã¨TTSã®å¼·åˆ¶åœæ­¢ã¨å†èµ·å‹•)
        sendBtn.addEventListener("click", () => {
            if (recognition) {
                recognition.stop();
                recognition = null;
            }
            if(synth.speaking) synth.cancel(); 

            // isSpeakingã¨isRecordingã‚’å¼·åˆ¶çš„ã«falseã«
            isSpeaking = false;
            isRecording = false;

            // AudioContextãŒsuspendedã®å ´åˆã€resumeã‚’è©¦ã¿ã‚‹
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.error("AudioContext resume failed:", e));
            }
            
            initAudioAndSTT();
            updateStatus('ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚ãƒã‚¤ã‚¯å…¥åŠ›ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...'); 
        });


        // UI ãƒˆã‚°ãƒ«æ©Ÿèƒ½ (ç”»é¢ã‚¿ãƒƒãƒ—) 
        let uiVisible = true; 
        tapArea.addEventListener('click', (e) => {
            // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã¸ã®ã‚¿ãƒƒãƒ—ã¯ç„¡è¦–
            if (e.target.closest('#input-controls') || e.target.closest('#status-area')) {
                return;
            }

            uiVisible = !uiVisible;
            if (uiVisible) {
                ui.style.opacity = 1; 
            } else {
                ui.style.opacity = 0; 
            }
        });

        /* ---------- Start-up ---------- */
        window.onload = function() {
            createBars();
            animateBars();
            initAudioAndSTT(); // ãƒã‚¤ã‚¯åˆæœŸåŒ–ã¨STTã‚’è‡ªå‹•ã§é–‹å§‹
            setStandbyStatus();
            
            // UIã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§è¡¨ç¤ºçŠ¶æ…‹ã«ã™ã‚‹
            ui.style.opacity = 1; 
            uiVisible = true;
        }
    </script>
</body>
</html>

Â  Â  Â  Â 


<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ã‚¤ãƒã‚¸ãƒ³ã•ã‚“ AIã€€ãƒ–ãƒãƒ¥ãƒ–ãƒãƒ¥ãƒãƒ³ã¾ãŸã¯ã¶ã¤ã¶ã¤ãƒãƒ³ Voice Assistant (è‡ªå‹•é€£ç¶šèªè­˜ + VAD)</title>
<style>
/* CSSéƒ¨åˆ†ã¯å¤‰æ›´ãªã— */
    :root{--accent:#00ffff;--accent-2:#00ffaa;--bg:#0f0f0f}
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Segoe UI,system-ui,Arial}
    canvas{position:fixed;inset:0;z-index:0}
    
    /* ğŸ’¡ UIã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³/ã‚¢ã‚¦ãƒˆã¨ã‚¿ãƒƒãƒ—é ˜åŸŸã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #ui{
        position:absolute;left:50%;bottom:5%;transform:translateX(-50%);z-index:10;width:min(980px,94vw);
        opacity: 1; /* åˆæœŸè¡¨ç¤º */
        transition: opacity 0.5s ease-in-out; /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š */
    }
    /* ç”»é¢å…¨ä½“ã‚’ã‚¿ãƒƒãƒ—é ˜åŸŸã¨ã—ã¦è¨­å®š */
    #tapArea {
        position: fixed;
        inset: 0;
        z-index: 5; /* UIã®ä¸‹ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸Šã«é…ç½® */
    }

    #status-area{padding:14px 20px;border-radius:12px;background:rgba(0,0,0,0.45);box-shadow:0 0 20px #00ffff55;color:var(--accent);font-weight:700}
    #controls{display:flex;gap:12px;margin-top:10px;align-items:center}
    #messageInput{flex:1;padding:12px 14px;border-radius:10px;border:1px solid rgba(0,255,255,0.15);background:rgba(255,255,255,0.03);color:#fff;font-size:16px}
    button{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
    #micBtn{background:var(--accent-2);color:#000} /* ã“ã®ãƒœã‚¿ãƒ³ã¯æ©Ÿèƒ½çš„ã«ã¯ä½¿ã‚ãªã„ãŒã€CSSã¯æ®‹ã™ */
    #resetBtn{background:var(--accent);color:#000}
    #modeIndicator{padding:8px 10px;border-radius:8px;background:#00000044;font-size:0.9rem}
    #subtext{margin-top:8px;color:#bfeeff}
    .active{box-shadow:0 0 20px #ff5555}
    #transcript{margin-top:12px;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);min-height:48px;font-size:16px}
</style>
</head>
<body>
<canvas id="waveCanvas"></canvas>

<div id="tapArea"></div>

<div id="ui">
    <div id="status-area">Initializing...</div>
    <div id="controls">
        <input id="messageInput" placeholder="è©±ã—ã‹ã‘ã¦ãã ã•ã„..." disabled> <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
        <div id="modeIndicator">STT/LLM/IoT</div>
    </div>
    <div id="subtext">é€£ç¶šèªè­˜ãƒ¢ãƒ¼ãƒ‰ï¼ˆVADã«ã‚ˆã‚‹è‡ªå‹•ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚¹ãƒˆãƒƒãƒ—ï¼‰</div>
    <div id="transcript"></div>
</div><script>
// Canvasç’°å¢ƒã§ã¯è‡ªå‹•ã§APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¾ã™
const API_KEY = ""; 
const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';
// ğŸ’¡ MQTT FastAPI ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®URL (mqtt_fastapi_backend.py ãŒãƒãƒ¼ãƒˆ8000ã§å‹•ä½œ)
const MQTT_API_URL = "http://127.0.0.1:8000/control"; 

/* ---------- DOM ---------- */
const statusArea = document.getElementById('status-area');
const resetBtn = document.getElementById('resetBtn');
const input = document.getElementById('messageInput');
const modeIndicator = document.getElementById('modeIndicator');
const transcriptBox = document.getElementById('transcript');
const ui = document.getElementById('ui'); 
const tapArea = document.getElementById('tapArea'); 

/* ---------- Audio / Waveform ---------- */
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d');
function resizeCanvas(){canvas.width = innerWidth; canvas.height = innerHeight}
window.addEventListener('resize', resizeCanvas); resizeCanvas();

let audioContext, analyser, mediaStream;
let isRecording = false; // éŸ³å£°èªè­˜ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
let recognition = null; // Web Speech API SpeechRecognition Object

/* ---------- UI helpers ---------- */
function status(msg){ statusArea.textContent = msg }

/* ---------- Speech Recognition (Browser STT) & Audio Init ---------- */

/**
 * Web Speech APIã«ã‚ˆã‚‹éŸ³å£°èªè­˜ã‚’é–‹å§‹ã—ã¾ã™ã€‚
 * ã“ã®é–¢æ•°ã¯ã€ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã€audioContextãŒæº–å‚™ã§ãã¦ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚
 */
function startBrowserRecognition() {
    // æ—¢ã«å®Ÿè¡Œä¸­ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (isRecording) return;
    
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        status('Error: Speech Recognition not supported in this browser.');
        return;
    }

    // æ—¢å­˜ã®èªè­˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¯ãƒªã‚¢
    if (recognition) {
        recognition.stop();
        recognition = null;
    }

    recognition = new (window.webkitSpeechRecognition || window.SpeechRecognition)();

    // é€£ç¶šèªè­˜ãƒ¢ãƒ¼ãƒ‰ (ç™ºè©±ã®åˆ‡ã‚Œç›®ã§è‡ªå‹•åœæ­¢)
    recognition.continuous = false; 
    recognition.interimResults = true; 
    recognition.lang = 'ja-JP';

    recognition.onstart = () => {
        isRecording = true;
        status('Listening...');
        input.value = 'è©±ã—ã¦ã„ã¾ã™...';
    };

    recognition.onresult = (event) => {
        let interimTranscript = '';
        let finalTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
                finalTranscript += event.results[i][0].transcript;
            } else {
                interimTranscript += event.results[i][0].transcript;
            }
        }

        transcriptBox.textContent = finalTranscript || interimTranscript;
        input.value = finalTranscript || interimTranscript;
    };

    // ğŸ’¡ ç™ºè©±çµ‚äº†ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼æ™‚ã®è‡ªå‹•å†ã‚¹ã‚¿ãƒ¼ãƒˆãƒ­ã‚¸ãƒƒã‚¯
    const restartRecognition = () => {
        status('Recognition stopped. Restarting...');
        setTimeout(() => {
            try {
                recognition.start();
            } catch (e) {
                // æ—¢ã«å®Ÿè¡Œä¸­ã®å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–
                if (e.name !== 'InvalidStateError') {
                    console.warn('Recognition start failed:', e);
                }
            }
        }, 500); 
    };
    
    recognition.onend = () => {
        isRecording = false;
        
        const finalPrompt = transcriptBox.textContent.trim();
        
        if (finalPrompt && finalPrompt.length > 1 && !finalPrompt.startsWith("AIå¿œç­”:")) { // çŸ­ã™ãã‚‹ç™ºè©±ã‚„AIå¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’ç„¡è¦–
            status('Processing response...');
            processRecognitionResult(finalPrompt).finally(() => {
                restartRecognition(); // å‡¦ç†å¾Œã«å†ã‚¹ã‚¿ãƒ¼ãƒˆ
            });
        } else {
            // èªè­˜çµæœãŒãªã„å ´åˆã¯å³åº§ã«å†ã‚¹ã‚¿ãƒ¼ãƒˆ
            transcriptBox.textContent = '';
            input.value = 'è©±ã—ã‹ã‘ã¦ãã ã•ã„...';
            restartRecognition();
        }
    };

    recognition.onerror = (event) => {
        isRecording = false;
        console.error('Speech Recognition Error:', event.error);
        
        // ğŸš¨ ä¿®æ­£ç®‡æ‰€: aborted, no-speech, network, audio-capture ã®å ´åˆã¯å†ã‚¹ã‚¿ãƒ¼ãƒˆã‚’è©¦ã¿ã‚‹
        if (event.error === 'aborted' || event.error === 'no-speech' || event.error === 'network' || event.error === 'audio-capture') {
            transcriptBox.textContent = '';
            input.value = 'è©±ã—ã‹ã‘ã¦ãã ã•ã„...';
            restartRecognition();
        } else {
            // ãã®ä»–ã®è‡´å‘½çš„ãªã‚¨ãƒ©ãƒ¼ï¼ˆä¾‹ï¼šnot-allowedãªã©ï¼‰
            status(`Error: ${event.error}. Please check microphone settings.`);
        }
    };

    // æœ€åˆã®ã‚¹ã‚¿ãƒ¼ãƒˆ
    try {
        recognition.start();
    } catch (e) {
        console.warn('Initial recognition start failed:', e);
    }
}

/**
 * ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¦æ±‚ã—ã€AudioContextã€æ³¢å½¢åˆ†æã€ãŠã‚ˆã³STTã‚’è¨­å®šã™ã‚‹
 */
async function initAudioAndSTT(){
    // æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯STTã ã‘å†ã‚¹ã‚¿ãƒ¼ãƒˆ
    if(analyser) {
        startBrowserRecognition();
        return;
    }
    status('Requesting microphone access...');

    try {
        // 1. AudioContextã®åˆæœŸåŒ–
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        
        // 2. ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const sourceNode = audioContext.createMediaStreamSource(mediaStream);
        
        // 3. æ¥ç¶šï¼ˆã‚½ãƒ¼ã‚¹ -> ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ï¼‰
        sourceNode.connect(analyser);

        // 4. ãƒ–ãƒ©ã‚¦ã‚¶STTã®é–‹å§‹
        startBrowserRecognition();

        status('Listening...');
    } catch (e) {
        console.error('Audio initialization failed:', e);
        status('Error: Microphone access denied or failed to initialize.');
    }
}

/**
 * ğŸ’¡ FastAPI/MQTTãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡ã™ã‚‹é–¢æ•°
 */
async function sendIoTCommand(command) {
    status(`Executing IoT command: ${command}...`);
    transcriptBox.textContent = `IoTã‚³ãƒãƒ³ãƒ‰: ${command} ã‚’å®Ÿè¡Œä¸­...`;
    
    try {
        const response = await fetch(MQTT_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ command: command })
        });

        const data = await response.json();

        if (response.ok) {
            // æˆåŠŸ
            const successMsg = `æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚${command === 'ON' ? 'é›»æ°—ã‚’ã¤ã‘ã¾ã—ãŸ' : 'é›»æ°—ã‚’æ¶ˆã—ã¾ã—ãŸ'}ã€‚`;
            console.log("IoT Success:", data);
            speak(successMsg);
        } else {
            // å¤±æ•— (HTTP 4xx/5xx ã‚¨ãƒ©ãƒ¼)
            const detail = data.detail || "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼";
            const errorMsg = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚IoTã‚³ãƒãƒ³ãƒ‰ '${command}' ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°: ${detail}`;
            console.error("IoT Error:", data);
            speak(errorMsg);
        }
    } catch (error) {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãªã©
        const networkErrorMsg = `ğŸ”´ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: IoTãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ (${error.message})`;
        console.error("IoT Network Error:", error);
        speak(networkErrorMsg);
    }
}


/* ---------- çµ±åˆã•ã‚ŒãŸãƒ¡ã‚¤ãƒ³å‡¦ç†é–¢æ•° (IoT or LLM) ---------- */

async function processRecognitionResult(finalPrompt) {
    // 1. IoTã‚³ãƒãƒ³ãƒ‰ã®åˆ¤å®šã¨æŒ¯ã‚Šåˆ†ã‘
    const lowerPrompt = finalPrompt.toLowerCase();
    let iotCommand = null;

    if ((lowerPrompt.includes('ãƒ©ã‚¤ãƒˆ') || lowerPrompt.includes('é›»æ°—')) && (lowerPrompt.includes('ã¤ã‘') || lowerPrompt.includes('ã‚ªãƒ³') || lowerPrompt.includes('ç‚¹ã‘'))) {
        iotCommand = 'ON';
    } else if ((lowerPrompt.includes('ãƒ©ã‚¤ãƒˆ') || lowerPrompt.includes('é›»æ°—')) && (lowerPrompt.includes('ã‘ã—') || lowerPrompt.includes('ã‚ªãƒ•') || lowerPrompt.includes('æ¶ˆã—'))) {
        iotCommand = 'OFF';
    }

    if (iotCommand) {
        // ğŸ’¡ ä¿®æ­£: ãƒ€ãƒŸãƒ¼ã§ã¯ãªãã€å®Ÿéš›ã®IoTã‚³ãƒãƒ³ãƒ‰é€ä¿¡é–¢æ•°ã‚’å‘¼ã³å‡ºã™
        await sendIoTCommand(iotCommand);
        return; 
    }
    
    // 2. LLMå¿œç­”ç”Ÿæˆï¼ˆIoTã‚³ãƒãƒ³ãƒ‰ã§ãªã‹ã£ãŸå ´åˆï¼‰
    await generateAndSpeakResponse(finalPrompt);
}


/* ---------- LLM (Gemini) API & TTS é€£æº ---------- */
async function generateAndSpeakResponse(prompt) {
    status('Generating response (Gemini)...');
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€ŒAIå¿œç­”:ã€ã¨ã„ã†ãƒ†ã‚­ã‚¹ãƒˆã‚’è©±ã—ãŸå ´åˆã€ãã‚Œã‚’é™¤å¤–ã™ã‚‹
    const cleanedPrompt = prompt.replace(/^AIå¿œç­”:\s*/, '').trim();
    if (!cleanedPrompt) {
        return; 
    }

    const systemInstruction = "ã‚ãªãŸã¯ã€Œã‚¤ãƒã‚¸ãƒ³ã•ã‚“ AIã€ã¨ã„ã†åå‰ã®ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªéŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã«æ—¥æœ¬èªã§ã€ç°¡æ½”ã‹ã¤ä¸å¯§ã«ç­”ãˆã¦ãã ã•ã„ã€‚";

    const payload = {
        prompt: cleanedPrompt,
// Â  Â  Â  Â  max_length: 1000 // ã‚µãƒ¼ãƒãƒ¼å´ã§å‡¦ç†
        contents: [{ parts: [{ text: cleanedPrompt }] }],
        systemInstruction: { parts: [{ text: systemInstruction }] },
        tools: [{ "google_search": {} }], 
    };
    
    // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    const MAX_RETRIES = 3;
    let responseText = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚AIã®å¿œç­”ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚";

    for (let i = 0; i < MAX_RETRIES; i++) {
        try {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${API_KEY}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (response.status === 429 && i < MAX_RETRIES - 1) {
                // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®å ´åˆã€æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§å†è©¦è¡Œ
                const delay = 2 ** i * 1000 + Math.random() * 1000;
                console.warn(`Rate limit hit. Retrying in ${delay / 1000}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
            }

            if (!response.ok) {
                throw new Error(`HTTP Error! Status: ${response.status}`);
            }
            
            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                responseText = candidate.content.parts[0].text;
                break; // æˆåŠŸ
            } else {
                 throw new Error("Empty response or invalid structure from Gemini.");
            }

        } catch (e) {
            console.error(`Gemini API error on attempt ${i + 1}:`, e);
            if (i === MAX_RETRIES - 1) {
                // æœ€å¾Œã®è©¦è¡Œã§å¤±æ•—ã—ãŸå ´åˆ
                responseText = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚AIã®å¿œç­”ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¾ãŸã¯APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
            } else {
                // è‡´å‘½çš„ã§ãªã„ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€å†è©¦è¡Œã®ãŸã‚ã«å¾…æ©Ÿ
                const delay = 2 ** i * 1000 + Math.random() * 500;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    status('Speaking response...');
    speak(responseText); 
}

/* ---------- TTS (Speech Synthesis) ---------- */
const synth = window.speechSynthesis;

function speak(text){ 
    if(!text) return; 
    
    // é€£ç¶šå‘¼ã³å‡ºã—æŠ‘åˆ¶ã¨ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†
    if(synth.speaking) synth.cancel(); 
    
    // å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’ transcriptBox ã«è¡¨ç¤º
    transcriptBox.textContent = "AIå¿œç­”: " + text;
    input.value = "AIå¿œç­”ä¸­...";

    const u = new SpeechSynthesisUtterance(text); 
    u.lang='ja-JP'; 
    u.rate=1.0; 
    u.onstart=()=>{ 
        status('Speaking...'); 
        input.value = "AIå¿œç­”ä¸­...";
    }; 
    u.onend=()=>{ 
        // èª­ã¿ä¸Šã’çµ‚äº†å¾Œã€STTã®onendãƒ­ã‚¸ãƒƒã‚¯ã§å†ã‚¹ã‚¿ãƒ¼ãƒˆã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯çŠ¶æ…‹ã‚’æˆ»ã™
        status('Ready to listen...'); 
        input.value = "è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
    }; 
    u.onerror = (e) => {
        console.error('TTS error:', e);
        status('TTS Error. Ready to listen...');
        input.value = "è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
    };

    synth.speak(u); 
}


/* ---------- UI ãƒˆã‚°ãƒ«æ©Ÿèƒ½ (ç”»é¢ã‚¿ãƒƒãƒ—) ---------- */
let uiVisible = true;
tapArea.addEventListener('click', (e) => {
    // è¨˜å…¥æ¬„ã‚„ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã¸ã®ã‚¿ãƒƒãƒ—ã¯ç„¡è¦–ã™ã‚‹
    if (e.target.closest('#controls') || e.target.closest('#transcript')) {
        return;
    }

    uiVisible = !uiVisible;
    if (uiVisible) {
        ui.style.opacity = 1; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
    } else {
        ui.style.opacity = 0; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
    }
});


/* ---------- Controls ---------- */
resetBtn.addEventListener('click', ()=>{ 
    // STTã¨TTSã‚’å¼·åˆ¶åœæ­¢
    if (recognition) {
        recognition.stop();
        recognition = null;
    }
    if(synth.speaking) synth.cancel(); 

    input.value=''; 
    transcriptBox.textContent=''; 
    
    // å†åº¦éŒ²éŸ³ã‚’é–‹å§‹
    initAudioAndSTT();
    status('Reset. Listening...'); 
});


/* ---------- Start-up ---------- */
window.onload = function() {
    // 1. èµ·å‹•æ™‚ã«ãƒã‚¤ã‚¯åˆæœŸåŒ–ã¨STTã‚’è‡ªå‹•ã§é–‹å§‹
    initAudioAndSTT();

    // 2. Waveformã®è¦–è¦šãƒ«ãƒ¼ãƒ—
    (function loopCanvas(){
        if(analyser){
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const bufferLen = analyser.frequencyBinCount; 
            const data = new Float32Array(bufferLen);
            analyser.getFloatTimeDomainData(data); 

            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.beginPath();
            const mid = canvas.height*0.55; 
            const step = canvas.width / bufferLen;
            
            let x = 0; 
            for(let i=0;i<bufferLen;i++){ 
                // èªè­˜ä¸­ã‹ã©ã†ã‹ã§æŒ¯å¹…ã‚’èª¿æ•´
                // ğŸ’¡ ä¿®æ­£ç‚¹: æŒ¯å¹…ã‚’ 0.9 ã‹ã‚‰ 1.2 ã¸ã€å¾…æ©Ÿæ™‚ã‚’ 0.2 ã‹ã‚‰ 0.3 ã¸å¢—ã‚„ã—ã¦ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ã«
                const amp = isRecording ? 1.2 : 0.3; 
                const y=mid + data[i]*mid*amp; 
                x = i * step; 
                if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y) 
            }
            ctx.strokeStyle='rgba(0,230,255,0.9)'; ctx.lineWidth=2; ctx.stroke();
        }
        requestAnimationFrame(loopCanvas);
    })();
};
</script></body>
</html>


<!-- <!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ã‚¤ãƒã‚¸ãƒ³ã•ã‚“ AIã€€ãƒ–ãƒãƒ¥ãƒ–ãƒãƒ¥ãƒãƒ³ã¾ãŸã¯ã¶ã¤ã¶ã¤ãƒãƒ³ Voice Assistant (è‡ªå‹•é€£ç¶šèªè­˜ + VAD)</title>
<style>
/* CSSéƒ¨åˆ†ã¯å¤‰æ›´ãªã— */
    :root{--accent:#00ffff;--accent-2:#00ffaa;--bg:#0f0f0f}
    html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:Segoe UI,system-ui,Arial}
    canvas{position:fixed;inset:0;z-index:0}
    
    /* ğŸ’¡ UIã®ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³/ã‚¢ã‚¦ãƒˆã¨ã‚¿ãƒƒãƒ—é ˜åŸŸã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #ui{
        position:absolute;left:50%;bottom:5%;transform:translateX(-50%);z-index:10;width:min(980px,94vw);
        opacity: 1; /* åˆæœŸè¡¨ç¤º */
        transition: opacity 0.5s ease-in-out; /* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š */
    }
    /* ç”»é¢å…¨ä½“ã‚’ã‚¿ãƒƒãƒ—é ˜åŸŸã¨ã—ã¦è¨­å®š */
    #tapArea {
        position: fixed;
        inset: 0;
        z-index: 5; /* UIã®ä¸‹ã€ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä¸Šã«é…ç½® */
    }

    #status-area{padding:14px 20px;border-radius:12px;background:rgba(0,0,0,0.45);box-shadow:0 0 20px #00ffff55;color:var(--accent);font-weight:700}
    #controls{display:flex;gap:12px;margin-top:10px;align-items:center}
    #messageInput{flex:1;padding:12px 14px;border-radius:10px;border:1px solid rgba(0,255,255,0.15);background:rgba(255,255,255,0.03);color:#fff;font-size:16px}
    button{padding:10px 14px;border-radius:10px;border:none;cursor:pointer;font-weight:700}
    #micBtn{background:var(--accent-2);color:#000} /* ã“ã®ãƒœã‚¿ãƒ³ã¯æ©Ÿèƒ½çš„ã«ã¯ä½¿ã‚ãªã„ãŒã€CSSã¯æ®‹ã™ */
    #resetBtn{background:var(--accent);color:#000}
    #modeIndicator{padding:8px 10px;border-radius:8px;background:#00000044;font-size:0.9rem}
    #subtext{margin-top:8px;color:#bfeeff}
    .active{box-shadow:0 0 20px #ff5555}
    #transcript{margin-top:12px;padding:12px;border-radius:10px;background:rgba(255,255,255,0.02);min-height:48px;font-size:16px}
</style>
</head>
<body>
<canvas id="waveCanvas"></canvas>

<div id="tapArea"></div>

<div id="ui">
    <div id="status-area">Initializing...</div>
    <div id="controls">
        <input id="messageInput" placeholder="è©±ã—ã‹ã‘ã¦ãã ã•ã„..." disabled> <button id="resetBtn">ãƒªã‚»ãƒƒãƒˆ</button>
        <div id="modeIndicator">STT/LLM/IoT</div>
    </div>
    <div id="subtext">é€£ç¶šèªè­˜ãƒ¢ãƒ¼ãƒ‰ï¼ˆVADã«ã‚ˆã‚‹è‡ªå‹•ã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚¹ãƒˆãƒƒãƒ—ï¼‰</div>
    <div id="transcript"></div>
</div><script>
// Canvasç’°å¢ƒã§ã¯è‡ªå‹•ã§APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¾ã™
const API_KEY = ""; 
const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';
// ğŸ’¡ MQTT FastAPI ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®URL (mqtt_fastapi_backend.py ãŒãƒãƒ¼ãƒˆ8000ã§å‹•ä½œ)
const MQTT_API_URL = "http://127.0.0.1:8000/control"; 

/* ---------- DOM ---------- */
const statusArea = document.getElementById('status-area');
const resetBtn = document.getElementById('resetBtn');
const input = document.getElementById('messageInput');
const modeIndicator = document.getElementById('modeIndicator');
const transcriptBox = document.getElementById('transcript');
const ui = document.getElementById('ui'); 
const tapArea = document.getElementById('tapArea'); 

/* ---------- Audio / Waveform ---------- */
const canvas = document.getElementById('waveCanvas');
const ctx = canvas.getContext('2d');
function resizeCanvas(){canvas.width = innerWidth; canvas.height = innerHeight}
window.addEventListener('resize', resizeCanvas); resizeCanvas();

let audioContext, analyser, mediaStream;
let isRecording = false; // éŸ³å£°èªè­˜ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ã©ã†ã‹
let recognition = null; // Web Speech API SpeechRecognition Object

/* ---------- UI helpers ---------- */
function status(msg){ statusArea.textContent = msg }

/* ---------- Speech Recognition (Browser STT) & Audio Init ---------- */

/**
 * Web Speech APIã«ã‚ˆã‚‹éŸ³å£°èªè­˜ã‚’é–‹å§‹ã—ã¾ã™ã€‚
 * ã“ã®é–¢æ•°ã¯ã€ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ãŒæˆåŠŸã—ã€audioContextãŒæº–å‚™ã§ãã¦ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚
 */
function startBrowserRecognition() {
    // æ—¢ã«å®Ÿè¡Œä¸­ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (isRecording) return;
    
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        status('Error: Speech Recognition not supported in this browser.');
        return;
    }

    // æ—¢å­˜ã®èªè­˜ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ã‚¯ãƒªã‚¢
    if (recognition) {
        recognition.stop();
        recognition = null;
    }

    recognition = new (window.webkitSpeechRecognition || window.SpeechRecognition)();

    // é€£ç¶šèªè­˜ãƒ¢ãƒ¼ãƒ‰ (ç™ºè©±ã®åˆ‡ã‚Œç›®ã§è‡ªå‹•åœæ­¢)
    recognition.continuous = false; 
    recognition.interimResults = true; 
    recognition.lang = 'ja-JP';

    recognition.onstart = () => {
        isRecording = true;
        status('Listening...');
        input.value = 'è©±ã—ã¦ã„ã¾ã™...';
    };

    recognition.onresult = (event) => {
        let interimTranscript = '';
        let finalTranscript = '';

        for (let i = event.resultIndex; i < event.results.length; ++i) {
            if (event.results[i].isFinal) {
                finalTranscript += event.results[i][0].transcript;
            } else {
                interimTranscript += event.results[i][0].transcript;
            }
        }

        transcriptBox.textContent = finalTranscript || interimTranscript;
        input.value = finalTranscript || interimTranscript;
    };

    // ğŸ’¡ ç™ºè©±çµ‚äº†ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼æ™‚ã®è‡ªå‹•å†ã‚¹ã‚¿ãƒ¼ãƒˆãƒ­ã‚¸ãƒƒã‚¯
    const restartRecognition = () => {
        status('Recognition stopped. Restarting...');
        setTimeout(() => {
            try {
                recognition.start();
            } catch (e) {
                // æ—¢ã«å®Ÿè¡Œä¸­ã®å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’ç„¡è¦–
                if (e.name !== 'InvalidStateError') {
                    console.warn('Recognition start failed:', e);
                }
            }
        }, 500); 
    };
    
    recognition.onend = () => {
        isRecording = false;
        
        const finalPrompt = transcriptBox.textContent.trim();
        
        if (finalPrompt && finalPrompt.length > 1 && !finalPrompt.startsWith("AIå¿œç­”:")) { // çŸ­ã™ãã‚‹ç™ºè©±ã‚„AIå¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’ç„¡è¦–
            status('Processing response...');
            processRecognitionResult(finalPrompt).finally(() => {
                restartRecognition(); // å‡¦ç†å¾Œã«å†ã‚¹ã‚¿ãƒ¼ãƒˆ
            });
        } else {
            // èªè­˜çµæœãŒãªã„å ´åˆã¯å³åº§ã«å†ã‚¹ã‚¿ãƒ¼ãƒˆ
            transcriptBox.textContent = '';
            input.value = 'è©±ã—ã‹ã‘ã¦ãã ã•ã„...';
            restartRecognition();
        }
    };

    recognition.onerror = (event) => {
        isRecording = false;
        console.error('Speech Recognition Error:', event.error);
        
        if (event.error !== 'no-speech' && event.error !== 'aborted') {
            // è‡´å‘½çš„ã§ãªã„ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€å†ã‚¹ã‚¿ãƒ¼ãƒˆã‚’è©¦ã¿ã‚‹
            restartRecognition();
        } else if (event.error === 'no-speech' || event.error === 'network') {
            // ç„¡éŸ³ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã®å ´åˆã‚‚å†ã‚¹ã‚¿ãƒ¼ãƒˆ
            transcriptBox.textContent = '';
            input.value = 'è©±ã—ã‹ã‘ã¦ãã ã•ã„...';
            restartRecognition();
        }
    };

    // æœ€åˆã®ã‚¹ã‚¿ãƒ¼ãƒˆ
    try {
        recognition.start();
    } catch (e) {
        console.warn('Initial recognition start failed:', e);
    }
}

/**
 * ãƒã‚¤ã‚¯ã‚¢ã‚¯ã‚»ã‚¹ã‚’è¦æ±‚ã—ã€AudioContextã€æ³¢å½¢åˆ†æã€ãŠã‚ˆã³STTã‚’è¨­å®šã™ã‚‹
 */
async function initAudioAndSTT(){
    // æ—¢ã«åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯STTã ã‘å†ã‚¹ã‚¿ãƒ¼ãƒˆ
    if(analyser) {
        startBrowserRecognition();
        return;
    }
    status('Requesting microphone access...');

    try {
        // 1. AudioContextã®åˆæœŸåŒ–
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        
        // 2. ãƒã‚¤ã‚¯ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const sourceNode = audioContext.createMediaStreamSource(mediaStream);
        
        // 3. æ¥ç¶šï¼ˆã‚½ãƒ¼ã‚¹ -> ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ï¼‰
        sourceNode.connect(analyser);

        // 4. ãƒ–ãƒ©ã‚¦ã‚¶STTã®é–‹å§‹
        startBrowserRecognition();

        status('Listening...');
    } catch (e) {
        console.error('Audio initialization failed:', e);
        status('Error: Microphone access denied or failed to initialize.');
    }
}

/**
 * ğŸ’¡ æ–°è¦è¿½åŠ : FastAPI/MQTTãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ã‚³ãƒãƒ³ãƒ‰ã‚’é€ä¿¡ã™ã‚‹é–¢æ•°
 */
async function sendIoTCommand(command) {
    status(`Executing IoT command: ${command}...`);
    transcriptBox.textContent = `IoTã‚³ãƒãƒ³ãƒ‰: ${command} ã‚’å®Ÿè¡Œä¸­...`;
    
    try {
        const response = await fetch(MQTT_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ command: command })
        });

        const data = await response.json();

        if (response.ok) {
            // æˆåŠŸ
            const successMsg = `æ‰¿çŸ¥ã—ã¾ã—ãŸã€‚${command === 'ON' ? 'é›»æ°—ã‚’ã¤ã‘ã¾ã—ãŸ' : 'é›»æ°—ã‚’æ¶ˆã—ã¾ã—ãŸ'}ã€‚`;
            console.log("IoT Success:", data);
            speak(successMsg);
        } else {
            // å¤±æ•— (HTTP 4xx/5xx ã‚¨ãƒ©ãƒ¼)
            const detail = data.detail || "ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼";
            const errorMsg = `ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚IoTã‚³ãƒãƒ³ãƒ‰ '${command}' ã®å®Ÿè¡Œã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°: ${detail}`;
            console.error("IoT Error:", data);
            speak(errorMsg);
        }
    } catch (error) {
        // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãªã©
        const networkErrorMsg = `ğŸ”´ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: IoTãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã«æ¥ç¶šã§ãã¾ã›ã‚“ (${error.message})`;
        console.error("IoT Network Error:", error);
        speak(networkErrorMsg);
    }
}


/* ---------- çµ±åˆã•ã‚ŒãŸãƒ¡ã‚¤ãƒ³å‡¦ç†é–¢æ•° (IoT or LLM) ---------- */

async function processRecognitionResult(finalPrompt) {
    // 1. IoTã‚³ãƒãƒ³ãƒ‰ã®åˆ¤å®šã¨æŒ¯ã‚Šåˆ†ã‘
    const lowerPrompt = finalPrompt.toLowerCase();
    let iotCommand = null;

    if ((lowerPrompt.includes('ãƒ©ã‚¤ãƒˆ') || lowerPrompt.includes('é›»æ°—')) && (lowerPrompt.includes('ã¤ã‘') || lowerPrompt.includes('ã‚ªãƒ³') || lowerPrompt.includes('ç‚¹ã‘'))) {
        iotCommand = 'ON';
    } else if ((lowerPrompt.includes('ãƒ©ã‚¤ãƒˆ') || lowerPrompt.includes('é›»æ°—')) && (lowerPrompt.includes('ã‘ã—') || lowerPrompt.includes('ã‚ªãƒ•') || lowerPrompt.includes('æ¶ˆã—'))) {
        iotCommand = 'OFF';
    }

    if (iotCommand) {
        // ğŸ’¡ ä¿®æ­£: ãƒ€ãƒŸãƒ¼ã§ã¯ãªãã€å®Ÿéš›ã®IoTã‚³ãƒãƒ³ãƒ‰é€ä¿¡é–¢æ•°ã‚’å‘¼ã³å‡ºã™
        await sendIoTCommand(iotCommand);
        return; 
    }
    
    // 2. LLMå¿œç­”ç”Ÿæˆï¼ˆIoTã‚³ãƒãƒ³ãƒ‰ã§ãªã‹ã£ãŸå ´åˆï¼‰
    await generateAndSpeakResponse(finalPrompt);
}


/* ---------- LLM (Gemini) API & TTS é€£æº ---------- */
async function generateAndSpeakResponse(prompt) {
    status('Generating response (Gemini)...');
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€ŒAIå¿œç­”:ã€ã¨ã„ã†ãƒ†ã‚­ã‚¹ãƒˆã‚’è©±ã—ãŸå ´åˆã€ãã‚Œã‚’é™¤å¤–ã™ã‚‹
    const cleanedPrompt = prompt.replace(/^AIå¿œç­”:\s*/, '').trim();
    if (!cleanedPrompt) {
        return; 
    }

    const systemInstruction = "ã‚ãªãŸã¯ã€Œã‚¤ãƒã‚¸ãƒŠãƒªãƒ¼ãƒŠãƒ³ãƒãƒ¼ é€šç§°GAIã‚¤ãƒã•ã‚“ã€ã¨ã„ã†åå‰ã®ãƒ•ãƒ¬ãƒ³ãƒ‰ãƒªãƒ¼ãªéŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è³ªå•ã«æ—¥æœ¬èªã§ã€ç°¡æ½”ã‹ã¤ä¸å¯§ã«ç­”ãˆã¦ãã ã•ã„ã€‚";

    const payload = {
        contents: [{ parts: [{ text: cleanedPrompt }] }],
        systemInstruction: { parts: [{ text: systemInstruction }] },
        tools: [{ "google_search": {} }], 
    };
    
    // æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã®ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    const MAX_RETRIES = 3;
    let responseText = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚AIã®å¿œç­”ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚";

    for (let i = 0; i < MAX_RETRIES; i++) {
        try {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent?key=${API_KEY}`;
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            
            if (response.status === 429 && i < MAX_RETRIES - 1) {
                // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã®å ´åˆã€æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•ã§å†è©¦è¡Œ
                const delay = 2 ** i * 1000 + Math.random() * 1000;
                console.warn(`Rate limit hit. Retrying in ${delay / 1000}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                continue;
            }

            if (!response.ok) {
                throw new Error(`HTTP Error! Status: ${response.status}`);
            }
            
            const result = await response.json();
            const candidate = result.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                responseText = candidate.content.parts[0].text;
                break; // æˆåŠŸ
            } else {
                 throw new Error("Empty response or invalid structure from Gemini.");
            }

        } catch (e) {
            console.error(`Gemini API error on attempt ${i + 1}:`, e);
            if (i === MAX_RETRIES - 1) {
                // æœ€å¾Œã®è©¦è¡Œã§å¤±æ•—ã—ãŸå ´åˆ
                responseText = "ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚AIã®å¿œç­”ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã¾ãŸã¯APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚";
            } else {
                // è‡´å‘½çš„ã§ãªã„ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€å†è©¦è¡Œã®ãŸã‚ã«å¾…æ©Ÿ
                const delay = 2 ** i * 1000 + Math.random() * 500;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    status('Speaking response...');
    speak(responseText); 
}

/* ---------- TTS (Speech Synthesis) ---------- */
const synth = window.speechSynthesis;

function speak(text){ 
    if(!text) return; 
    
    // é€£ç¶šå‘¼ã³å‡ºã—æŠ‘åˆ¶ã¨ã‚­ãƒ£ãƒ³ã‚»ãƒ«å‡¦ç†
    if(synth.speaking) synth.cancel(); 
    
    // å¿œç­”ãƒ†ã‚­ã‚¹ãƒˆã‚’ transcriptBox ã«è¡¨ç¤º
    transcriptBox.textContent = "AIå¿œç­”: " + text;
    input.value = "AIå¿œç­”ä¸­...";

    const u = new SpeechSynthesisUtterance(text); 
    u.lang='ja-JP'; 
    u.rate=1.0; 
    u.onstart=()=>{ 
        status('Speaking...'); 
        input.value = "AIå¿œç­”ä¸­...";
    }; 
    u.onend=()=>{ 
        // èª­ã¿ä¸Šã’çµ‚äº†å¾Œã€STTã®onendãƒ­ã‚¸ãƒƒã‚¯ã§å†ã‚¹ã‚¿ãƒ¼ãƒˆã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯çŠ¶æ…‹ã‚’æˆ»ã™
        status('Ready to listen...'); 
        input.value = "è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
    }; 
    u.onerror = (e) => {
        console.error('TTS error:', e);
        status('TTS Error. Ready to listen...');
        input.value = "è©±ã—ã‹ã‘ã¦ãã ã•ã„...";
    };

    synth.speak(u); 
}


/* ---------- UI ãƒˆã‚°ãƒ«æ©Ÿèƒ½ (ç”»é¢ã‚¿ãƒƒãƒ—) ---------- */
let uiVisible = true;
tapArea.addEventListener('click', (e) => {
    // è¨˜å…¥æ¬„ã‚„ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã¸ã®ã‚¿ãƒƒãƒ—ã¯ç„¡è¦–ã™ã‚‹
    if (e.target.closest('#controls') || e.target.closest('#transcript')) {
        return;
    }

    uiVisible = !uiVisible;
    if (uiVisible) {
        ui.style.opacity = 1; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
    } else {
        ui.style.opacity = 0; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
    }
});


/* ---------- Controls ---------- */
resetBtn.addEventListener('click', ()=>{ 
    // STTã¨TTSã‚’å¼·åˆ¶åœæ­¢
    if (recognition) {
        recognition.stop();
        recognition = null;
    }
    if(synth.speaking) synth.cancel(); 

    input.value=''; 
    transcriptBox.textContent=''; 
    
    // å†åº¦éŒ²éŸ³ã‚’é–‹å§‹
    initAudioAndSTT();
    status('Reset. Listening...'); 
});


/* ---------- Start-up ---------- */
window.onload = function() {
    // 1. èµ·å‹•æ™‚ã«ãƒã‚¤ã‚¯åˆæœŸåŒ–ã¨STTã‚’è‡ªå‹•ã§é–‹å§‹
    initAudioAndSTT();

    // 2. Waveformã®è¦–è¦šãƒ«ãƒ¼ãƒ—
    (function loopCanvas(){
        if(analyser){
            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const bufferLen = analyser.frequencyBinCount; 
            const data = new Float32Array(bufferLen);
            analyser.getFloatTimeDomainData(data); 

            ctx.clearRect(0,0,canvas.width,canvas.height);
            ctx.beginPath();
            const mid = canvas.height*0.55; 
            const step = canvas.width / bufferLen;
            
            let x = 0; 
            for(let i=0;i<bufferLen;i++){ 
                // èªè­˜ä¸­ã‹ã©ã†ã‹ã§æŒ¯å¹…ã‚’èª¿æ•´
                const amp = isRecording ? 0.9 : 0.2; 
                const y=mid + data[i]*mid*amp; 
                x = i * step; 
                if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y) 
            }
            ctx.strokeStyle='rgba(0,230,255,0.9)'; ctx.lineWidth=2; ctx.stroke();
        }
        requestAnimationFrame(loopCanvas);
    })();
};
</script></body>
</html> -->